diff --git a/.gitignore b/.gitignore
index 87d425c..6cba691 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,8 +1,9 @@
 #Folders
+*.vscode
 .idea
 build
 cmake-build-debug
 cmake-build-release
 thirdparty/Micro-CDR/CMakeFiles
 include/rtps/config.h
-CMakeFiles
\ No newline at end of file
+CMakeFiles
diff --git a/include/rtps/ThreadPool.h b/include/rtps/ThreadPool.h
index aafc59f..b25eec1 100644
--- a/include/rtps/ThreadPool.h
+++ b/include/rtps/ThreadPool.h
@@ -56,6 +56,8 @@ public:
   static void readCallback(void *arg, udp_pcb *pcb, pbuf *p,
                            const ip_addr_t *addr, Ip4Port_t port);
 
+  bool addBuiltinPort(const Ip4Port_t& port);
+
 private:
   receiveJumppad_fp m_receiveJumppad;
   void *m_callee;
@@ -63,15 +65,26 @@ private:
   std::array<sys_thread_t, Config::THREAD_POOL_NUM_WRITERS> m_writers;
   std::array<sys_thread_t, Config::THREAD_POOL_NUM_READERS> m_readers;
 
+  std::array<Ip4Port_t, 2*Config::MAX_NUM_PARTICIPANTS> m_builtinPorts;
+  size_t m_builtinPortsIdx = 0;
+
   sys_sem_t m_readerNotificationSem;
   sys_sem_t m_writerNotificationSem;
 
-  ThreadSafeCircularBuffer<Writer *, Config::THREAD_POOL_WORKLOAD_QUEUE_LENGTH>
-      m_queueOutgoing;
-  ThreadSafeCircularBuffer<PacketInfo,
-                           Config::THREAD_POOL_WORKLOAD_QUEUE_LENGTH>
-      m_queueIncoming;
+  void updateDiagnostics();
+
+  using BufferUsertrafficOutgoing = ThreadSafeCircularBuffer<Writer *, Config::THREAD_POOL_WORKLOAD_QUEUE_LENGTH_USERTRAFFIC>;
+  using BufferMetatrafficOutgoing = ThreadSafeCircularBuffer<Writer *, Config::THREAD_POOL_WORKLOAD_QUEUE_LENGTH_METATRAFFIC>;
+  using BufferUsertrafficIncoming = ThreadSafeCircularBuffer<PacketInfo, Config::THREAD_POOL_WORKLOAD_QUEUE_LENGTH_USERTRAFFIC>;
+  using BufferMetatrafficIncoming = ThreadSafeCircularBuffer<PacketInfo, Config::THREAD_POOL_WORKLOAD_QUEUE_LENGTH_METATRAFFIC>;
+
+  BufferUsertrafficOutgoing m_outgoingUserTraffic;
+  BufferMetatrafficOutgoing m_outgoingMetaTraffic;
+
+  BufferUsertrafficIncoming m_incomingUserTraffic;
+  BufferMetatrafficIncoming m_incomingMetaTraffic;
 
+  bool isBuiltinPort(const Ip4Port_t& port);
   static void writerThreadFunction(void *arg);
   static void readerThreadFunction(void *arg);
   void doWriterWork();
diff --git a/include/rtps/common/types.h b/include/rtps/common/types.h
index 15a660f..3207d56 100644
--- a/include/rtps/common/types.h
+++ b/include/rtps/common/types.h
@@ -30,6 +30,7 @@ Author: i11 - Embedded Software, RWTH Aachen University
 #include <array>
 #include <cstdint>
 #include <initializer_list>
+#include <limits>
 
 // TODO subnamespaces
 namespace rtps {
@@ -174,6 +175,17 @@ struct SequenceNumber_t {
     return *this;
   }
 
+  SequenceNumber_t &operator--(){
+	  if(low == 0){
+		  --high;
+		  low = std::numeric_limits<decltype(low)>::max();
+	  }else{
+		  --low;
+	  }
+
+	  return *this;
+  }
+
   SequenceNumber_t operator++(int) {
     SequenceNumber_t tmp(*this);
     ++*this;
@@ -267,6 +279,7 @@ const EntityId_t ENTITYID_P2P_BUILTIN_PARTICIPANT_MESSAGE_READER = {
 
 const GuidPrefix_t GUIDPREFIX_UNKNOWN{};
 const Guid_t GUID_UNKNOWN{};
+const GuidPrefix_t GUID_RANDOM{9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};
 
 const ParticipantId_t PARTICIPANT_ID_INVALID = -1;
 
diff --git a/include/rtps/config_r5.h b/include/rtps/config_r5.h
deleted file mode 100644
index feb90cb..0000000
--- a/include/rtps/config_r5.h
+++ /dev/null
@@ -1,75 +0,0 @@
-#ifndef RTPS_CONFIG_H
-#define RTPS_CONFIG_H
-
-#include "rtps/common/types.h"
-
-namespace rtps {
-
-#define IS_LITTLE_ENDIAN 1
-
-namespace Config {
-const VendorId_t VENDOR_ID = {13, 37};
-const std::array<uint8_t, 4> IP_ADDRESS = {
-    137, 226, 8, 70}; // Needs to be set in lwipcfg.h too.
-const GuidPrefix_t BASE_GUID_PREFIX{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12};
-
-const uint8_t DOMAIN_ID = 0; // 230 possible with UDP
-const uint8_t NUM_STATELESS_WRITERS = 64;
-const uint8_t NUM_STATELESS_READERS = 64;
-const uint8_t NUM_STATEFUL_READERS = 4;
-const uint8_t NUM_STATEFUL_WRITERS = 4;
-const uint8_t MAX_NUM_PARTICIPANTS = 1;
-const uint8_t NUM_WRITERS_PER_PARTICIPANT =
-    64; // 3 will be reserved for SPDP & SEDP
-const uint8_t NUM_READERS_PER_PARTICIPANT =
-    64; // 3 will be reserved for SPDP & SEDP
-const uint8_t NUM_WRITER_PROXIES_PER_READER = 60;
-const uint8_t NUM_READER_PROXIES_PER_WRITER = 60;
-
-const uint8_t MAX_NUM_UNMATCHED_REMOTE_WRITERS = 150;
-const uint8_t MAX_NUM_UNMATCHED_REMOTE_READERS = 150;
-
-const uint8_t MAX_NUM_READER_CALLBACKS = 5;
-
-const uint8_t HISTORY_SIZE_STATELESS = 64;
-const uint8_t HISTORY_SIZE_STATEFUL = 64;
-
-const uint8_t MAX_TYPENAME_LENGTH = 64;
-const uint8_t MAX_TOPICNAME_LENGTH = 64;
-
-const int HEARTBEAT_STACKSIZE = 1200;          // byte
-const int THREAD_POOL_WRITER_STACKSIZE = 1100; // byte
-const int THREAD_POOL_READER_STACKSIZE = 3600; // byte
-const uint16_t SPDP_WRITER_STACKSIZE = 550;    // byte
-
-const uint16_t SF_WRITER_HB_PERIOD_MS = 4000;
-const uint16_t SPDP_RESEND_PERIOD_MS = 1000;
-const uint8_t SPDP_WRITER_PRIO = 3;
-const uint8_t SPDP_CYCLECOUNT_HEARTBEAT =
-    2; // Every X*SPDP_RESEND_PERIOD_MS, check for missing heartbeats
-const uint8_t SPDP_MAX_NUMBER_FOUND_PARTICIPANTS = 100;
-const uint8_t SPDP_MAX_NUM_LOCATORS = 1;
-const Duration_t SPDP_DEFAULT_REMOTE_LEASE_DURATION = {
-    5, 0}; // Default lease duration for remote participants, usually
-           // overwritten by remote info
-const Duration_t SPDP_MAX_REMOTE_LEASE_DURATION = {
-    180,
-    0}; // Absolute maximum lease duration, ignoring remote participant info
-
-const int MAX_NUM_UDP_CONNECTIONS = 10;
-
-const int THREAD_POOL_NUM_WRITERS = 1;
-const int THREAD_POOL_NUM_READERS = 1;
-const int THREAD_POOL_WRITER_PRIO = 3;
-const int THREAD_POOL_READER_PRIO = 3;
-const int THREAD_POOL_WORKLOAD_QUEUE_LENGTH = 10;
-
-constexpr int OVERALL_HEAP_SIZE =
-    THREAD_POOL_NUM_WRITERS * THREAD_POOL_WRITER_STACKSIZE +
-    THREAD_POOL_NUM_READERS * THREAD_POOL_READER_STACKSIZE +
-    MAX_NUM_PARTICIPANTS * SPDP_WRITER_STACKSIZE +
-    NUM_STATEFUL_WRITERS * HEARTBEAT_STACKSIZE;
-} // namespace Config
-} // namespace rtps
-
-#endif // RTPS_CONFIG_H
diff --git a/include/rtps/discovery/SEDPAgent.h b/include/rtps/discovery/SEDPAgent.h
index c351358..90f4cb8 100644
--- a/include/rtps/discovery/SEDPAgent.h
+++ b/include/rtps/discovery/SEDPAgent.h
@@ -54,8 +54,8 @@ public:
   uint32_t getNumRemoteUnmatchedWriters();
 
 protected: // For testing purposes
-  void handlePublisherReaderMessage(const TopicData &writerData);
-  void handleSubscriptionReaderMessage(const TopicData &writerData);
+  void handlePublisherReaderMessage(const TopicData &writerData, const ReaderCacheChange& change);
+  void handleSubscriptionReaderMessage(const TopicData &writerData, const ReaderCacheChange& change);
 
 private:
   Participant *m_part;
@@ -82,7 +82,7 @@ private:
   void addUnmatchedRemoteWriter(const TopicDataCompressed &writerData);
   void addUnmatchedRemoteReader(const TopicDataCompressed &readerData);
 
-  void handleRemoteEndpointDeletion(const TopicData &topic);
+  void handleRemoteEndpointDeletion(const TopicData &topic, const ReaderCacheChange& change);
 
   void (*mfp_onNewPublisherCallback)(void *arg) = nullptr;
   void *m_onNewPublisherArgs = nullptr;
diff --git a/include/rtps/discovery/TopicData.h b/include/rtps/discovery/TopicData.h
index 49b8dbf..8f3eead 100644
--- a/include/rtps/discovery/TopicData.h
+++ b/include/rtps/discovery/TopicData.h
@@ -58,7 +58,7 @@ struct TopicData {
   TopicData()
       : endpointGuid(GUID_UNKNOWN), typeName{'\0'}, topicName{'\0'},
         reliabilityKind(ReliabilityKind_t::BEST_EFFORT),
-        durabilityKind(DurabilityKind_t::TRANSIENT_LOCAL) {
+        durabilityKind(DurabilityKind_t::VOLATILE) {
     rtps::FullLengthLocator someLocator =
         rtps::FullLengthLocator::createUDPv4Locator(
             192, 168, 0, 42, rtps::getUserUnicastPort(0));
@@ -69,7 +69,7 @@ struct TopicData {
   TopicData(Guid_t guid, ReliabilityKind_t reliability, FullLengthLocator loc)
       : endpointGuid(guid), typeName{'\0'}, topicName{'\0'},
         reliabilityKind(reliability),
-        durabilityKind(DurabilityKind_t::TRANSIENT_LOCAL), unicastLocator(loc) {
+        durabilityKind(DurabilityKind_t::VOLATILE), unicastLocator(loc) {
   }
 
   bool matchesTopicOf(const TopicData &other);
diff --git a/include/rtps/entities/Domain.h b/include/rtps/entities/Domain.h
index bdc981d..480217d 100644
--- a/include/rtps/entities/Domain.h
+++ b/include/rtps/entities/Domain.h
@@ -62,6 +62,9 @@ public:
 
   void printInfo();
 
+  bool isParticipantBuiltinPort();
+  bool isParticipantUnicastPort();
+
 private:
   friend class SizeInspector;
   ThreadPool m_threadPool;
diff --git a/include/rtps/entities/Reader.h b/include/rtps/entities/Reader.h
index 5a64695..7671a98 100644
--- a/include/rtps/entities/Reader.h
+++ b/include/rtps/entities/Reader.h
@@ -110,9 +110,11 @@ public:
   using dumpProxyCallback = void (*)(const Reader *reader, const WriterProxy &,
                                      void *arg);
 
-  //! Dangerous, only
+
   int dumpAllProxies(dumpProxyCallback target, void *arg);
 
+  virtual bool sendPreemptiveAckNack(const WriterProxy &writer);
+
 protected:
   void executeCallbacks(const ReaderCacheChange &cacheChange);
   bool initMutex();
diff --git a/include/rtps/entities/ReaderProxy.h b/include/rtps/entities/ReaderProxy.h
index dbdab1b..678bd1e 100644
--- a/include/rtps/entities/ReaderProxy.h
+++ b/include/rtps/entities/ReaderProxy.h
@@ -41,9 +41,17 @@ struct ReaderProxy {
   bool finalFlag = false;
   SequenceNumber_t lastAckNackSequenceNumber = {0, 1};
 
+  void reset(){
+	useMulticast = false;
+	suppressUnicast = false;
+	unknown_eid = false;
+	ackNackCount = {0};
+	lastAckNackSequenceNumber = {0, 1};
+  }
+
   ReaderProxy()
       : remoteReaderGuid({GUIDPREFIX_UNKNOWN, ENTITYID_UNKNOWN}),
-        finalFlag(false){};
+		ackNackCount{0}, remoteLocator(LocatorIPv4()), finalFlag(false){};
   ReaderProxy(const Guid_t &guid, const LocatorIPv4 &loc, bool reliable)
       : remoteReaderGuid(guid), remoteLocator(loc),
         is_reliable(reliable), ackNackCount{0}, finalFlag(false){};
diff --git a/include/rtps/entities/StatefulReader.h b/include/rtps/entities/StatefulReader.h
index 04a897e..55497f9 100644
--- a/include/rtps/entities/StatefulReader.h
+++ b/include/rtps/entities/StatefulReader.h
@@ -46,6 +46,8 @@ public:
   bool onNewGapMessage(const SubmessageGap &msg,
                        const GuidPrefix_t &remotePrefix) override;
 
+  bool sendPreemptiveAckNack(const WriterProxy &writer) override;
+
 private:
   Ip4Port_t m_srcPort; // TODO intended for reuse but buffer not used as such
   NetworkDriver *m_transport;
diff --git a/include/rtps/entities/StatefulReader.tpp b/include/rtps/entities/StatefulReader.tpp
index 5ff53fc..4e6347d 100644
--- a/include/rtps/entities/StatefulReader.tpp
+++ b/include/rtps/entities/StatefulReader.tpp
@@ -28,6 +28,7 @@ Author: i11 - Embedded Software, RWTH Aachen University
 #include "rtps/messages/MessageFactory.h"
 #include "rtps/utils/Lock.h"
 #include "rtps/utils/Log.h"
+#include "rtps/utils/Diagnostics.h"
 
 #if SFR_VERBOSE && RTPS_GLOBAL_VERBOSE
 #include "rtps/utils/printutils.h"
@@ -35,7 +36,7 @@ Author: i11 - Embedded Software, RWTH Aachen University
   if (true) {                                                                  \
     printf("[StatefulReader %s] ", &m_attributes.topicName[0]);                \
     printf(__VA_ARGS__);                                                       \
-    printf("\n");                                                              \
+    printf("\r\n");                                                              \
   }
 #else
 #define SFR_LOG(...) //
@@ -71,9 +72,16 @@ void StatefulReaderT<NetworkDriver>::newChange(
   for (auto &proxy : m_proxies) {
     if (proxy.remoteWriterGuid == cacheChange.writerGuid) {
       if (proxy.expectedSN == cacheChange.sn) {
+    	printf("Delivering SN %u.%u | ! GUID %u %u %u %u \r\n", (int)cacheChange.sn.high, (int)cacheChange.sn.low, cacheChange.writerGuid.prefix.id[0], cacheChange.writerGuid.prefix.id[1],cacheChange.writerGuid.prefix.id[2],cacheChange.writerGuid.prefix.id[3]);
         executeCallbacks(cacheChange);
         ++proxy.expectedSN;
+        printf("Done processing SN %u.%u\r\n", (int)cacheChange.sn.high, (int)cacheChange.sn.low );
         return;
+      }else{
+    	  Diagnostics::StatefulReader::sfr_unexpected_sn++;
+    	  printf("Unexpected SN %u.%u != %u.%u, dropping! GUID %u %u %u %u | \r\n", (int)proxy.expectedSN.high,(int)proxy.expectedSN.low, (int)cacheChange.sn.high, (int)cacheChange.sn.low,
+    			  cacheChange.writerGuid.prefix.id[0], cacheChange.writerGuid.prefix.id[1],cacheChange.writerGuid.prefix.id[2],cacheChange.writerGuid.prefix.id[3]);
+
       }
     }
   }
@@ -97,6 +105,7 @@ bool StatefulReaderT<NetworkDriver>::onNewGapMessage(
   if (!m_is_initialized_) {
     return false;
   }
+  SFR_LOG("Processing gap message %u %u", msg.gapStart, msg.gapList.base);
 
   Guid_t writerProxyGuid;
   writerProxyGuid.prefix = remotePrefix;
@@ -114,14 +123,62 @@ bool StatefulReaderT<NetworkDriver>::onNewGapMessage(
     return false;
   }
 
-  // We have not seen all messages leading up to gap start -> do nothing
-  if (writer->expectedSN < msg.gapStart) {
-    printf("GAP: Ignoring Gap, we have not seen all messages prior to gap "
-           "begin: %u < %u\n",
-           int(writer->expectedSN.low), int(msg.gapStart.low));
-    return true;
+  // Case 1: We are still waiting for messages before gapStart
+  if(writer->expectedSN < msg.gapStart){
+	  PacketInfo info;
+	  info.srcPort = m_srcPort;
+	  info.destAddr = writer->remoteLocator.getIp4Address();
+	  info.destPort = writer->remoteLocator.port;
+	  rtps::MessageFactory::addHeader(info.buffer,
+									   m_attributes.endpointGuid.prefix);
+	  SequenceNumber_t last_valid = msg.gapStart;
+	  --last_valid;
+	  auto missing_sns = writer->getMissing(writer->expectedSN, last_valid);
+	  rtps::MessageFactory::addAckNack(info.buffer, msg.writerId, msg.readerId, missing_sns                                   ,
+										writer->getNextAckNackCount(), false);
+	  m_transport->sendPacket(info);
+      return true;
   }
 
+  // Case 2: We are expecting a message between [gapStart; gapList.base -1]
+  // Advance expectedSN beyond gapList.base
+  if(writer->expectedSN < msg.gapList.base){
+	  auto before = writer->expectedSN;
+	  writer->expectedSN = msg.gapList.base;
+
+	  //writer->expectedSN++;
+
+	  // Advance expectedSN to first unset bit
+      uint32_t bit;
+      for(uint32_t bit = 0; bit < SNS_MAX_NUM_BITS; writer->expectedSN++, bit++){
+    	  if(!msg.gapList.isSet(bit)){
+    		  break;
+    	  }
+      }
+
+
+      printf("#2 GAP Case-> before expectedSN = %u < gapList.base = %u | gapStart %u | new expectedSN %u \r\n",
+    		  before.low , msg.gapList.base.low, msg.gapStart.low, writer->expectedSN.low);
+
+      return true;
+
+      PacketInfo info;
+      info.srcPort = m_srcPort;
+      info.destAddr = writer->remoteLocator.getIp4Address();
+      info.destPort = writer->remoteLocator.port;
+      rtps::MessageFactory::addHeader(info.buffer,
+                                      m_attributes.endpointGuid.prefix);
+
+
+      SequenceNumberSet request_set;
+      request_set.base = writer->expectedSN;
+      request_set.bitMap[0]  = uint32_t{1} << 31;
+      // Send AckNack
+	  return true;
+  }
+
+  return true;
+
   // Start from base and search for first unset bit
   SequenceNumber_t first_valid = msg.gapList.base;
   for (unsigned int i = 0; i < msg.gapList.numBits; i++, first_valid++) {
@@ -182,10 +239,9 @@ bool StatefulReaderT<NetworkDriver>::onNewHeartbeat(
     return false;
   }
 
-  if (msg.count.value <= writer->hbCount.value) {
-
-    SFR_LOG("Ignore heartbeat. Count too low.\n");
-    return false;
+  if(writer->expectedSN < msg.firstSN){
+	  SFR_LOG("expectedSN < firstSN, advancing expectedSN");
+	  writer->expectedSN = msg.firstSN;
   }
 
   writer->hbCount.value = msg.count.value;
@@ -193,11 +249,39 @@ bool StatefulReaderT<NetworkDriver>::onNewHeartbeat(
   info.destPort = writer->remoteLocator.port;
   rtps::MessageFactory::addHeader(info.buffer,
                                   m_attributes.endpointGuid.prefix);
-  rtps::MessageFactory::addAckNack(info.buffer, msg.writerId, msg.readerId,
-                                   writer->getMissing(msg.firstSN, msg.lastSN),
-                                   writer->getNextAckNackCount(), false);
+  auto missing_sns = writer->getMissing(msg.firstSN, msg.lastSN);
+  bool final_flag = (missing_sns.numBits == 0);
+  rtps::MessageFactory::addAckNack(info.buffer, msg.writerId, msg.readerId, missing_sns                                   ,
+                                   writer->getNextAckNackCount(), final_flag);
 
-  SFR_LOG("Sending acknack.\n");
+  SFR_LOG("Sending acknack base %u bits %u .\n", (int)missing_sns.base.low, (int)missing_sns.numBits);
   m_transport->sendPacket(info);
   return true;
 }
+
+template <class NetworkDriver>
+bool StatefulReaderT<NetworkDriver>::sendPreemptiveAckNack(
+    const WriterProxy &writer){
+  Lock lock(m_proxies_mutex);
+  if (!m_is_initialized_) {
+    return false;
+  }
+
+  PacketInfo info;
+  info.srcPort = m_attributes.unicastLocator.port;
+  info.destAddr = writer.remoteLocator.getIp4Address();
+  info.destPort = writer.remoteLocator.port;
+  rtps::MessageFactory::addHeader(info.buffer,
+                                  m_attributes.endpointGuid.prefix);
+  SequenceNumberSet number_set;
+  number_set.base.high = 0;
+  number_set.base.low = 0;
+  number_set.numBits = 0;
+  rtps::MessageFactory::addAckNack(info.buffer, writer.remoteWriterGuid.entityId, m_attributes.endpointGuid.entityId, number_set, Count_t{1}, false);
+
+  SFR_LOG("Sending preemptive acknack.\n");
+  m_transport->sendPacket(info);
+  return true;
+ }
+
+
diff --git a/include/rtps/entities/StatefulWriter.h b/include/rtps/entities/StatefulWriter.h
index ad6ffc4..57bcbdb 100644
--- a/include/rtps/entities/StatefulWriter.h
+++ b/include/rtps/entities/StatefulWriter.h
@@ -56,6 +56,16 @@ private:
   NetworkDriver *m_transport;
 
   HistoryCacheWithDeletion<Config::HISTORY_SIZE_STATEFUL> m_history;
+
+  /*
+   * Cache changes marked as disposeAfterWrite are retained for a short amount in case of retransmission
+   * The whole 'disposeAfterWrite' mechanisms only exists to allow for repeated creation deletion of endpoints during operation.
+   * Otherwise, the history will quickly reach its limits.
+   * Will be replaced with something more elegant in the future.
+   */
+  ThreadSafeCircularBuffer<SequenceNumber_t, 10> m_disposeWithDelay;
+  void dropDisposeAfterWriteChanges();
+  
   sys_thread_t m_heartbeatThread;
 
   Count_t m_hbCount{1};
@@ -68,7 +78,7 @@ private:
   static void hbFunctionJumppad(void *thisPointer);
   void sendHeartBeatLoop();
   void sendHeartBeat();
-  void sendGap(const ReaderProxy &reader, const SequenceNumber_t &missingSN);
+  void sendGap(const ReaderProxy &reader, const SequenceNumber_t& firstMissing, const SequenceNumber_t& nextValid);
 };
 
 using StatefulWriter = StatefulWriterT<UdpDriver>;
diff --git a/include/rtps/entities/StatefulWriter.tpp b/include/rtps/entities/StatefulWriter.tpp
index 319d278..25c6a42 100644
--- a/include/rtps/entities/StatefulWriter.tpp
+++ b/include/rtps/entities/StatefulWriter.tpp
@@ -38,7 +38,7 @@ using rtps::StatefulWriterT;
   if (true) {                                                                  \
     printf("[Stateful Writer %s] ", this->m_attributes.topicName);             \
     printf(__VA_ARGS__);                                                       \
-    printf("\n");                                                              \
+    printf("\r\n");                                                              \
   }
 #else
 #define SFW_LOG(...) //
@@ -85,6 +85,8 @@ bool StatefulWriterT<NetworkDriver>::init(TopicData attributes,
   m_history.clear();
   m_hbCount = {1};
 
+  m_disposeWithDelay.init();
+
   // Thread already exists, do not create new one (reusing slot case)
   m_is_initialized_ = true;
 
@@ -135,11 +137,12 @@ const rtps::CacheChange *StatefulWriterT<NetworkDriver>::newChange(
   if (m_history.isFull()) {
     // Right now we drop elements anyway because we cannot detect non-responding
     // readers yet. return nullptr;
-    SequenceNumber_t newMin = ++SequenceNumber_t(m_history.getSeqNumMin());
+    SequenceNumber_t newMin = ++SequenceNumber_t(m_history.getCurrentSeqNumMin());
     if (m_nextSequenceNumberToSend < newMin) {
       m_nextSequenceNumberToSend =
           newMin; // Make sure we have the correct sn to send
     }
+    SFW_LOG("History full! Dropping changes.\r\n");
   }
 
   auto *result =
@@ -158,14 +161,22 @@ template <class NetworkDriver> void StatefulWriterT<NetworkDriver>::progress() {
   Lock{m_mutex};
   CacheChange *next = m_history.getChangeBySN(m_nextSequenceNumberToSend);
   if (next != nullptr) {
+	uint32_t i = 0;
     for (const auto &proxy : m_proxies) {
       if (!m_enforceUnicast) {
         sendDataWRMulticast(proxy, next);
       } else {
+    	  i++;
         sendData(proxy, next);
       }
     }
 
+    SFW_LOG("Sending data with SN %u.%u", (int)m_nextSequenceNumberToSend.low, (int)m_nextSequenceNumberToSend.high);
+
+    if(next->disposeAfterWrite){
+    	SFW_LOG("Dispose after write msg sent to %u proxies\r\n", (int)i);
+    }
+
     /*
      * Use case: deletion of local endpoints
      * -> send Data Message with Disposed Flag set
@@ -174,15 +185,25 @@ template <class NetworkDriver> void StatefulWriterT<NetworkDriver>::progress() {
      * -> onAckNack will send Gap Messages to skip deleted local endpoints
      * during SEDP
      */
-    if (next->diposeAfterWrite) {
-      m_history.dropChange(next->sequenceNumber);
+    if (next->disposeAfterWrite) {
+      next->sentTickCount = xTaskGetTickCount();
+      if(!m_disposeWithDelay.copyElementIntoBuffer(next->sequenceNumber)){
+    	  printf("Failed to enqueue dispose after write!");
+    	  m_history.dropChange(next->sequenceNumber);
+      }else{
+          printf("Delayed dispose scheduled for sn %u %u\r\n",  (int)next->sequenceNumber.high, (int)next->sequenceNumber.low);
+      }
     }
+
+    ++m_nextSequenceNumberToSend;
+    sendHeartBeat();
+
   } else {
     SFW_LOG("Couldn't get a CacheChange with SN (%i,%u)\n",
             m_nextSequenceNumberToSend.high, m_nextSequenceNumberToSend.low);
   }
 
-  ++m_nextSequenceNumberToSend;
+
 }
 
 template <class NetworkDriver>
@@ -190,13 +211,14 @@ void StatefulWriterT<NetworkDriver>::setAllChangesToUnsent() {
   INIT_GUARD()
   Lock lock(m_mutex);
 
-  m_nextSequenceNumberToSend = m_history.getSeqNumMin();
+  m_nextSequenceNumberToSend = m_history.getCurrentSeqNumMin();
 
   if (mp_threadPool != nullptr) {
     mp_threadPool->addWorkload(this);
   }
 }
 
+
 template <class NetworkDriver>
 void StatefulWriterT<NetworkDriver>::onNewAckNack(
     const SubmessageAckNack &msg, const GuidPrefix_t &sourceGuidPrefix) {
@@ -224,53 +246,92 @@ void StatefulWriterT<NetworkDriver>::onNewAckNack(
     return;
   }
 
-  if (msg.count.value <= reader->ackNackCount.value) {
-
-    SFW_LOG("Count too small. Dropping acknack.\n");
-
-    return;
-  }
-
   reader->ackNackCount = msg.count;
   reader->finalFlag = msg.header.finalFlag();
   reader->lastAckNackSequenceNumber = msg.readerSNState.base;
 
-  // Send missing packets
-  SequenceNumber_t nextSN = msg.readerSNState.base;
 
-  if (nextSN.low == 0 && nextSN.high == 0) {
-    SFW_LOG("Received preemptive acknack. Ignored.\n");
-  } else {
-    SFW_LOG("Received non-preemptive acknack.\n");
-  }
+  rtps::SequenceNumber_t nextSN = msg.readerSNState.base;
 
-  for (uint32_t i = 0; i < msg.readerSNState.numBits; ++i, ++nextSN) {
-    if (msg.readerSNState.isSet(i)) {
-
-      SFW_LOG("Send Packet on acknack.\n");
-      const CacheChange *cache = m_history.getChangeBySN(nextSN);
-
-      // We should have this SN -> send GAP Message
-      if (cache == nullptr && m_history.isSNInRange(nextSN)) {
-        sendGap(*reader, nextSN);
-        continue;
-      }
+  // Preemptive ack nack
+  if (nextSN.low == 0 && nextSN.high == 0)
+  {
+    sendHeartBeat();
+    return;
+  }
 
-      if (cache != nullptr) {
-        sendData(*reader, cache);
-      }
+  if(m_history.isEmpty()){
+    // We have never sent anything -> heartbeat
+    if(m_history.getLastUsedSequenceNumber() == rtps::SequenceNumber_t{0,0}){
+      sendHeartBeat();
+    }else{
+      // No data but we have sent something in the past -> GapStart = readerSNState.base, NextValid = lastUsedSequenceNumber+1
+      rtps::SequenceNumber_t nextValid = m_history.getLastUsedSequenceNumber();
+      ++nextValid;
+      sendGap(*reader, msg.readerSNState.base, nextValid);
     }
+
+    return;
   }
-  // Check for sequence numbers after defined range
-  SequenceNumber_t maxSN;
-  { maxSN = m_history.getSeqNumMax(); }
-  while (nextSN <= maxSN) {
-    const CacheChange *cache = m_history.getChangeBySN(nextSN);
-    if (cache != nullptr) {
-      sendData(*reader, cache);
-    }
-    ++nextSN;
+
+  // Requesting smaller SN than minimum sequence number -> sendGap
+  if (msg.readerSNState.base < m_history.getCurrentSeqNumMin())
+  {
+    sendGap(*reader, msg.readerSNState.base, m_history.getCurrentSeqNumMin());
+    return;
   }
+
+  SFW_LOG("Received non-preemptive acknack with %u bits set.\r\n", msg.readerSNState.numBits);
+  for (uint32_t i = 0; i < msg.readerSNState.numBits && nextSN <= m_history.getLastUsedSequenceNumber(); ++i, ++nextSN)
+   {
+
+     if (msg.readerSNState.isSet(i))
+     {
+
+       printf("> Looking for change %u | Bit %u", nextSN.low, i);
+       const rtps::CacheChange *cache = m_history.getChangeBySN(nextSN);
+
+       // We still have the cache, send DATA
+       if (cache != nullptr)
+       {
+         if (cache->disposeAfterWrite)
+         {
+           printf("SERVING FROM DISPOSE AFTER WRITE CACHE\r\n");
+         }
+         sendData(*reader, cache);
+       }
+       else
+       {
+        printf("> Change not found, search for next valid SN %u \r\n", nextSN.low);
+         // Cache not found, look for next valid SN
+         rtps::SequenceNumber_t gapBegin = nextSN;
+         rtps::CacheChange *nextValidChange = nullptr;
+         uint32_t j = i+1;
+         for (++nextSN; nextSN <= m_history.getLastUsedSequenceNumber(); ++nextSN, ++j)
+         {
+           nextValidChange = m_history.getChangeBySN(nextSN);
+           if (nextValidChange != nullptr)
+           {
+             break;
+           }
+         }
+         if (nextValidChange == nullptr)
+         {
+           sendGap(*reader, gapBegin, nextSN);
+           return;
+         }
+         else
+         {
+           sendGap(*reader, gapBegin, nextValidChange->sequenceNumber);
+         }
+         //sendData(nullptr, nextValidChange);
+         nextSN = nextValidChange->sequenceNumber;
+         --nextSN;
+         i = --j;
+       }
+     }
+   }
+
 }
 
 template <class NetworkDriver>
@@ -310,7 +371,7 @@ bool StatefulWriterT<NetworkDriver>::sendData(const ReaderProxy &reader,
 
 template <class NetworkDriver>
 void StatefulWriterT<NetworkDriver>::sendGap(
-    const ReaderProxy &reader, const SequenceNumber_t &missingSN) {
+    const ReaderProxy &reader, const SequenceNumber_t& firstMissing, const SequenceNumber_t& nextValid) {
   INIT_GUARD()
   // TODO smarter packaging e.g. by creating MessageStruct and serialize after
   // adjusting values Reusing the pbuf is not possible. See
@@ -330,7 +391,7 @@ void StatefulWriterT<NetworkDriver>::sendGap(
 
   MessageFactory::addSubmessageGap(info.buffer,
                                    m_attributes.endpointGuid.entityId,
-                                   reader.remoteReaderGuid.entityId, missingSN);
+                                   reader.remoteReaderGuid.entityId, firstMissing, nextValid);
   m_transport->sendPacket(info);
 }
 
@@ -384,8 +445,23 @@ void StatefulWriterT<NetworkDriver>::sendHeartBeatLoop() {
   m_thread_running = true;
   while (m_running) {
     sendHeartBeat();
+    dropDisposeAfterWriteChanges();
 #ifdef OS_IS_FREERTOS
-    vTaskDelay(pdMS_TO_TICKS(Config::SF_WRITER_HB_PERIOD_MS));
+    bool unconfirmed_changes = false;
+    for(auto it : m_proxies){
+    	if(it.lastAckNackSequenceNumber < m_nextSequenceNumberToSend){
+    		unconfirmed_changes = true;
+    		break;
+    	}
+    }
+
+    // Temporarily increase HB frequency if there are unconfirmed remote changes
+    if(unconfirmed_changes){
+    	printf("HB SPEEDUP!\r\n");
+    	vTaskDelay(pdMS_TO_TICKS(Config::SF_WRITER_HB_PERIOD_MS/4));
+    }else{
+        vTaskDelay(pdMS_TO_TICKS(Config::SF_WRITER_HB_PERIOD_MS));
+    }
 #else
     sys_msleep(Config::SF_WRITER_HB_PERIOD_MS);
 #endif
@@ -393,6 +469,35 @@ void StatefulWriterT<NetworkDriver>::sendHeartBeatLoop() {
   m_thread_running = false;
 }
 
+template <class NetworkDriver>
+void StatefulWriterT<NetworkDriver>::dropDisposeAfterWriteChanges() {
+	SequenceNumber_t oldest_retained;
+	while(m_disposeWithDelay.peakFirst(oldest_retained)){
+
+		CacheChange* change = m_history.getChangeBySN(oldest_retained);
+		if(change == nullptr || !change->disposeAfterWrite){
+			// Not in history anymore, drop
+			m_disposeWithDelay.moveFirstInto(oldest_retained);
+			return;
+		}
+
+		auto age = (xTaskGetTickCount() - change->sentTickCount);
+		if(age > pdMS_TO_TICKS(4000)){
+			m_history.dropChange(change->sequenceNumber);
+			printf("Removing SN %u %u for good\r\n", static_cast<unsigned int>(oldest_retained.low),
+					static_cast<unsigned int>(oldest_retained.high));
+			SequenceNumber_t tmp;
+			m_disposeWithDelay.moveFirstInto(tmp);
+
+			continue;
+		}else{
+			return;
+		}
+
+	}
+
+}
+
 template <class NetworkDriver>
 void StatefulWriterT<NetworkDriver>::sendHeartBeat() {
   INIT_GUARD()
@@ -409,18 +514,38 @@ void StatefulWriterT<NetworkDriver>::sendHeartBeat() {
 
     SequenceNumber_t firstSN;
     SequenceNumber_t lastSN;
+
+
     MessageFactory::addHeader(info.buffer, m_attributes.endpointGuid.prefix);
+
     {
       Lock lock(m_mutex);
-      firstSN = m_history.getSeqNumMin();
-      lastSN = m_history.getSeqNumMax();
 
-      // Proxy has confirmed all sequence numbers and set final flag
-      if ((proxy.lastAckNackSequenceNumber > lastSN) && proxy.finalFlag &&
-          proxy.ackNackCount.value > 0) {
-        continue;
+      if(!m_history.isEmpty()){
+			firstSN = m_history.getCurrentSeqNumMin();
+			lastSN = m_history.getCurrentSeqNumMax();
+
+
+			// Otherwise we may announce changes that have not been sent at least once!
+			if(lastSN > m_nextSequenceNumberToSend || lastSN == m_nextSequenceNumberToSend){
+			  lastSN = m_nextSequenceNumberToSend;
+			  --lastSN;
+			}
+
+			// Proxy has confirmed all sequence numbers and set final flag
+			if ((proxy.lastAckNackSequenceNumber > lastSN) && proxy.finalFlag &&
+			  proxy.ackNackCount.value > 0) {
+			continue;
+			}
+      }else if(m_history.getLastUsedSequenceNumber() == SequenceNumber_t{0,0}){
+    	  firstSN = SequenceNumber_t{0,1};
+    	  lastSN = SequenceNumber_t{0,0};
+      }else{
+    	  firstSN = SequenceNumber_t{0,1};
+    	  lastSN = m_history.getLastUsedSequenceNumber();
       }
     }
+/*
     if (firstSN == SEQUENCENUMBER_UNKNOWN || lastSN == SEQUENCENUMBER_UNKNOWN) {
 
       if (strlen(&this->m_attributes.typeName[0]) != 0) {
@@ -428,6 +553,8 @@ void StatefulWriterT<NetworkDriver>::sendHeartBeat() {
       }
       return;
     }
+*/
+    SFW_LOG("Sending HB with SN range [%u.%u;%u.%u]",firstSN.low, firstSN.high, lastSN.low, lastSN.high);
 
     MessageFactory::addHeartbeat(
         info.buffer, m_attributes.endpointGuid.entityId,
diff --git a/include/rtps/entities/Writer.h b/include/rtps/entities/Writer.h
index 1653a0d..4edc29e 100644
--- a/include/rtps/entities/Writer.h
+++ b/include/rtps/entities/Writer.h
@@ -79,6 +79,8 @@ public:
   void setSEDPSequenceNumber(const SequenceNumber_t &sn);
   const SequenceNumber_t &getSEDPSequenceNumber();
 
+  bool isBuiltinEndpoint();
+
 protected:
   SequenceNumber_t m_sedp_sequence_number;
 
@@ -89,6 +91,8 @@ protected:
 
   bool m_enforceUnicast;
 
+  bool m_isBuiltinEndpoint = false;
+
   TopicKind_t m_topicKind = TopicKind_t::NO_KEY;
   SequenceNumber_t m_nextSequenceNumberToSend;
 
diff --git a/include/rtps/entities/WriterProxy.h b/include/rtps/entities/WriterProxy.h
index 0c01c19..6f0fc85 100644
--- a/include/rtps/entities/WriterProxy.h
+++ b/include/rtps/entities/WriterProxy.h
@@ -46,16 +46,20 @@ struct WriterProxy {
 
   // For now, we don't store any packets, so we just request all starting from
   // the next expected
-  SequenceNumberSet getMissing(const SequenceNumber_t & /*firstAvail*/,
+  SequenceNumberSet getMissing(const SequenceNumber_t & firstAvail,
                                const SequenceNumber_t &lastAvail) {
     SequenceNumberSet set;
     if (lastAvail < expectedSN) {
       set.base = expectedSN;
       set.numBits = 0;
     } else {
-      set.numBits = 1;
       set.base = expectedSN;
-      set.bitMap[0] = uint32_t{1} << 31;
+      SequenceNumber_t i;
+      uint32_t bit;
+      for(bit = 0, i = expectedSN; i <= lastAvail && bit < SNS_MAX_NUM_BITS; i++, bit++){
+        set.bitMap[0] |= uint32_t{1} << (31-bit);
+        set.numBits++;
+      }
     }
 
     return set;
diff --git a/include/rtps/messages/MessageFactory.h b/include/rtps/messages/MessageFactory.h
index 0869c4f..a95741b 100644
--- a/include/rtps/messages/MessageFactory.h
+++ b/include/rtps/messages/MessageFactory.h
@@ -176,7 +176,7 @@ void addAckNack(Buffer &buffer, EntityId_t writerId, EntityId_t readerId,
   if (final_flag) {
     subMsg.header.flags |= FLAG_FINAL; // For now, we don't want any response
   } else {
-    subMsg.header.flags &= ~FLAG_FINAL; // For now, we don't want any response
+    subMsg.header.flags &= ~FLAG_FINAL; // Send future heartbeats, even if no change occured
   }
   subMsg.header.octetsToNextHeader =
       SubmessageAckNack::getRawSize(readerSNState) - numBytesUntilEndOfLength;
@@ -191,7 +191,7 @@ void addAckNack(Buffer &buffer, EntityId_t writerId, EntityId_t readerId,
 
 template <class Buffer>
 void addSubmessageGap(Buffer &buffer, EntityId_t writerId, EntityId_t readerId,
-                      SequenceNumber_t missingSN) {
+                      const SequenceNumber_t& firstMissing, const SequenceNumber_t& nextValid) {
   SubmessageGap subMsg;
   subMsg.header.submessageId = SubmessageKind::GAP;
 #if IS_LITTLE_ENDIAN
@@ -203,8 +203,8 @@ void addSubmessageGap(Buffer &buffer, EntityId_t writerId, EntityId_t readerId,
 
   subMsg.writerId = writerId;
   subMsg.readerId = readerId;
-  subMsg.gapStart = missingSN;
-  subMsg.gapList.base = ++missingSN;
+  subMsg.gapStart = firstMissing;
+  subMsg.gapList.base = nextValid;
   subMsg.gapList.numBits = 0;
 
   serializeMessage(buffer, subMsg);
diff --git a/include/rtps/storages/CacheChange.h b/include/rtps/storages/CacheChange.h
index 23a7040..d249eab 100644
--- a/include/rtps/storages/CacheChange.h
+++ b/include/rtps/storages/CacheChange.h
@@ -32,7 +32,8 @@ namespace rtps {
 struct CacheChange {
   ChangeKind_t kind = ChangeKind_t::INVALID;
   bool inLineQoS = false;
-  bool diposeAfterWrite = false;
+  bool disposeAfterWrite = false;
+  TickType_t sentTickCount = 0;
   SequenceNumber_t sequenceNumber = SEQUENCENUMBER_UNKNOWN;
   PBufWrapper data{};
 
@@ -44,7 +45,12 @@ struct CacheChange {
     kind = ChangeKind_t::INVALID;
     sequenceNumber = SEQUENCENUMBER_UNKNOWN;
     inLineQoS = false;
-    diposeAfterWrite = false;
+    disposeAfterWrite = false;
+    sentTickCount = 0;
+  }
+
+  bool isInitialized(){
+	  return (kind != ChangeKind_t::INVALID);
   }
 };
 } // namespace rtps
diff --git a/include/rtps/storages/HistoryCacheWithDeletion.h b/include/rtps/storages/HistoryCacheWithDeletion.h
index ac1e436..67abd45 100644
--- a/include/rtps/storages/HistoryCacheWithDeletion.h
+++ b/include/rtps/storages/HistoryCacheWithDeletion.h
@@ -40,6 +40,8 @@ template <uint16_t SIZE> class HistoryCacheWithDeletion {
 public:
   HistoryCacheWithDeletion() = default;
 
+  uint32_t m_dispose_after_write_cnt = 0;
+
   bool isFull() const {
     uint16_t it = m_head;
     incrementIterator(it);
@@ -51,11 +53,15 @@ public:
     CacheChange change;
     change.kind = ChangeKind_t::ALIVE;
     change.inLineQoS = inLineQoS;
-    change.diposeAfterWrite = disposeAfterWrite;
+    change.disposeAfterWrite = disposeAfterWrite;
     change.data.reserve(size);
     change.data.append(data, size);
     change.sequenceNumber = ++m_lastUsedSequenceNumber;
 
+    if(disposeAfterWrite){
+    	m_dispose_after_write_cnt++;
+    }
+
     CacheChange *place = &m_buffer[m_head];
     incrementHead();
 
@@ -72,7 +78,7 @@ public:
       return;
     }
 
-    if (getSeqNumMax() <= sn) { // We won't overrun head
+    if (getCurrentSeqNumMax() <= sn) { // We won't overrun head
       m_head = m_tail;
       return;
     }
@@ -82,7 +88,7 @@ public:
     }
   }
 
-  void dropOldest() { removeUntilIncl(getSeqNumMin()); }
+  void dropOldest() { removeUntilIncl(getCurrentSeqNumMin()); }
 
   bool dropChange(const SequenceNumber_t &sn) {
     uint16_t idx_to_clear;
@@ -135,7 +141,11 @@ public:
     }
   }
 
-  const SequenceNumber_t &getSeqNumMin() const {
+  bool isEmpty(){
+	 return (m_head == m_tail);
+  }
+
+  const SequenceNumber_t &getCurrentSeqNumMin() const {
     if (m_head == m_tail) {
       return SEQUENCENUMBER_UNKNOWN;
     } else {
@@ -143,7 +153,7 @@ public:
     }
   }
 
-  const SequenceNumber_t &getSeqNumMax() const {
+  const SequenceNumber_t &getCurrentSeqNumMax() const {
     if (m_head == m_tail) {
       return SEQUENCENUMBER_UNKNOWN;
     } else {
@@ -151,6 +161,10 @@ public:
     }
   }
 
+  const SequenceNumber_t &getLastUsedSequenceNumber(){
+	  return m_lastUsedSequenceNumber;
+  }
+
   void clear() {
     m_head = 0;
     m_tail = 0;
@@ -183,8 +197,11 @@ public:
   }
 #endif
   bool isSNInRange(const SequenceNumber_t &sn) {
-    SequenceNumber_t minSN = getSeqNumMin();
-    if (sn < minSN || getSeqNumMax() < sn) {
+	if(isEmpty()){
+	  return false;
+	}
+    SequenceNumber_t minSN = getCurrentSeqNumMin();
+    if (sn < minSN || getCurrentSeqNumMax() < sn) {
       return false;
     }
     return true;
@@ -247,6 +264,9 @@ private:
   }
 
   inline void incrementTail() {
+	if(m_buffer[m_tail].disposeAfterWrite){
+		m_dispose_after_write_cnt--;
+	}
     if (m_head != m_tail) {
       m_buffer[m_tail].reset();
       incrementIterator(m_tail);
diff --git a/include/rtps/storages/MemoryPool.h b/include/rtps/storages/MemoryPool.h
index c36d489..a7d500c 100644
--- a/include/rtps/storages/MemoryPool.h
+++ b/include/rtps/storages/MemoryPool.h
@@ -66,7 +66,7 @@ public:
       uint32_t bucket;
       do {
         ++m_bit;
-        bucket = m_bit / static_cast<uint8_t>(8);
+        bucket = m_bit / static_cast<uint32_t>(8);
       } while (!(m_bitMap[bucket] & (1 << (m_bit % 8))) && m_bit < SIZE);
 
       return *this;
@@ -83,7 +83,7 @@ public:
     friend class MemoryPool;
     MemoryPool<TYPE, SIZE> &m_pool;
     uint8_t m_bitMap[SIZE / 8 + 1];
-    uint8_t m_bit = 0;
+    uint32_t m_bit = 0;
   };
 
   typedef MemoryPoolIterator<TYPE> MemPoolIter;
@@ -104,7 +104,7 @@ public:
       printf("[MemoryPool] RESSOURCE LIMIT EXCEEDED \n");
       return false;
     }
-    for (uint8_t bucket = 0; bucket < sizeof(m_bitMap); ++bucket) {
+    for (uint32_t bucket = 0; bucket < sizeof(m_bitMap); ++bucket) {
       if (m_bitMap[bucket] != 0xFF) {
         uint8_t byte = m_bitMap[bucket];
         for (uint8_t bit = 0; bit < 8; ++bit) {
@@ -137,10 +137,10 @@ public:
     bool retcode = false;
     for (auto it = begin(); it != end(); ++it) {
       if (jumppad(isCorrectElement, *it)) {
-        const uint8_t bucket = it.m_bit / uint8_t{8};
-        const uint8_t pos =
+        const uint8_t bucket = it.m_bit / uint32_t{8};
+        const uint32_t pos =
             it.m_bit &
-            uint8_t{
+            uint32_t{
                 7}; // 7 sets all bits above and including the one for 8 to 0
         m_bitMap[bucket] &= ~(static_cast<uint8_t>(1) << pos);
         --m_numElements;
diff --git a/include/rtps/storages/SimpleHistoryCache.h b/include/rtps/storages/SimpleHistoryCache.h
index 25313db..8391d23 100644
--- a/include/rtps/storages/SimpleHistoryCache.h
+++ b/include/rtps/storages/SimpleHistoryCache.h
@@ -52,7 +52,7 @@ public:
     CacheChange change;
     change.kind = ChangeKind_t::ALIVE;
     change.inLineQoS = inLineQoS;
-    change.diposeAfterWrite = disposeAfterWrite;
+    change.disposeAfterWrite = disposeAfterWrite;
     change.data.reserve(size);
     change.data.append(data, size);
     change.sequenceNumber = ++m_lastUsedSequenceNumber;
diff --git a/include/rtps/storages/ThreadSafeCircularBuffer.h b/include/rtps/storages/ThreadSafeCircularBuffer.h
index 5ea9eb5..0a5f6af 100644
--- a/include/rtps/storages/ThreadSafeCircularBuffer.h
+++ b/include/rtps/storages/ThreadSafeCircularBuffer.h
@@ -39,6 +39,8 @@ public:
   bool init();
 
   bool moveElementIntoBuffer(T &&elem);
+  bool copyElementIntoBuffer(const T& elem);
+
 
   /**
    * Removes the first into the given hull. Also moves responsibility for
@@ -46,6 +48,10 @@ public:
    * @return true if element was injected. False if no element was present.
    */
   bool moveFirstInto(T &hull);
+  bool peakFirst(T &hull);
+
+  uint32_t numElements();
+  uint32_t insertionFailures();
 
   void clear();
 
@@ -53,6 +59,8 @@ private:
   std::array<T, SIZE + 1> m_buffer{};
   uint16_t m_head = 0;
   uint16_t m_tail = 0;
+  uint32_t m_num_elements = 0;
+  uint32_t m_insertion_failures = 0;
   static_assert(SIZE + 1 < std::numeric_limits<decltype(m_head)>::max(),
                 "Iterator is large enough for given size");
 
diff --git a/include/rtps/storages/ThreadSafeCircularBuffer.tpp b/include/rtps/storages/ThreadSafeCircularBuffer.tpp
index 41ce60e..313565a 100644
--- a/include/rtps/storages/ThreadSafeCircularBuffer.tpp
+++ b/include/rtps/storages/ThreadSafeCircularBuffer.tpp
@@ -42,10 +42,25 @@ bool ThreadSafeCircularBuffer<T, SIZE>::moveElementIntoBuffer(T &&elem) {
     incrementHead();
     return true;
   } else {
+    m_insertion_failures++;
     return false;
   }
 }
 
+template <typename T, uint16_t SIZE>
+bool ThreadSafeCircularBuffer<T, SIZE>::copyElementIntoBuffer(const T& elem) {
+  Lock lock(m_mutex);
+  if (!isFull()) {
+    m_buffer[m_head] = elem;
+    incrementHead();
+    return true;
+  } else {
+    m_insertion_failures++;
+    return false;
+  }
+}
+
+
 template <typename T, uint16_t SIZE>
 bool ThreadSafeCircularBuffer<T, SIZE>::moveFirstInto(T &hull) {
   Lock lock(m_mutex);
@@ -58,10 +73,29 @@ bool ThreadSafeCircularBuffer<T, SIZE>::moveFirstInto(T &hull) {
   }
 }
 
+template <typename T, uint16_t SIZE>
+bool ThreadSafeCircularBuffer<T, SIZE>::peakFirst(T &hull) {
+  Lock lock(m_mutex);
+  if (m_head != m_tail) {
+    hull = m_buffer[m_tail];
+    return true;
+  } else {
+    return false;
+  }
+}
+
+template <typename T, uint16_t SIZE>
+uint32_t ThreadSafeCircularBuffer<T, SIZE>::numElements() {
+  return m_num_elements;
+}
+
+
+
 template <typename T, uint16_t SIZE>
 void ThreadSafeCircularBuffer<T, SIZE>::clear() {
   Lock lock(m_mutex);
   m_head = m_tail;
+  m_num_elements = 0;
 }
 
 template <typename T, uint16_t SIZE>
@@ -83,11 +117,14 @@ ThreadSafeCircularBuffer<T, SIZE>::incrementIterator(uint16_t &iterator) {
 template <typename T, uint16_t SIZE>
 inline void ThreadSafeCircularBuffer<T, SIZE>::incrementTail() {
   incrementIterator(m_tail);
+  m_num_elements--;
+
 }
 
 template <typename T, uint16_t SIZE>
 inline void ThreadSafeCircularBuffer<T, SIZE>::incrementHead() {
   incrementIterator(m_head);
+  m_num_elements++;
   if (m_head == m_tail) {
     incrementTail();
   }
diff --git a/include/rtps/utils/Diagnostics.h b/include/rtps/utils/Diagnostics.h
new file mode 100644
index 0000000..b67730a
--- /dev/null
+++ b/include/rtps/utils/Diagnostics.h
@@ -0,0 +1,84 @@
+/*
+The MIT License
+Copyright (c) 2019 Lehrstuhl Informatik 11 - RWTH Aachen University
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE
+
+This file is part of embeddedRTPS.
+
+Author: i11 - Embedded Software, RWTH Aachen University
+*/
+
+#ifndef RTPS_DIAGNOSTICS_H
+#define RTPS_DIAGNOSTICS_H
+
+#include <stdint.h>
+
+namespace rtps
+{
+  namespace Diagnostics
+  {
+
+    namespace ThreadPool
+    {
+      extern uint32_t dropped_packets_usertraffic;
+      extern uint32_t dropped_packets_metatraffic;
+
+      extern uint32_t max_ever_elements_outgoing_usertraffic_queue;
+      extern uint32_t max_ever_elements_incoming_usertraffic_queue;
+
+      extern uint32_t max_ever_elements_outgoing_metatraffic_queue;
+      extern uint32_t max_ever_elements_incoming_metatraffic_queue;
+    }
+
+    namespace StatefulReader
+    {
+      extern uint32_t sfr_unexpected_sn;
+      extern uint32_t sfr_retransmit_requests;
+    }
+
+    namespace Network
+    {
+      extern uint32_t lwip_allocation_failures;
+    }
+    
+    namespace OS
+    {
+      extern uint32_t current_free_heap_size;
+    }
+
+    namespace SEDP
+    {
+      extern uint32_t max_ever_remote_participants;
+      extern uint32_t current_remote_participants;
+
+      extern uint32_t max_ever_matched_reader_proxies;
+      extern uint32_t current_max_matched_reader_proxies;
+
+      extern uint32_t max_ever_matched_writer_proxies;
+      extern uint32_t current_max_matched_writer_proxies;
+
+      extern uint32_t max_ever_unmatched_reader_proxies;
+      extern uint32_t current_max_unmatched_reader_proxies;
+
+      extern uint32_t max_ever_unmatched_writer_proxies;
+      extern uint32_t current_max_unmatched_writer_proxies;
+    }
+
+  }
+}
+
+#endif
diff --git a/include/rtps/utils/Log.h b/include/rtps/utils/Log.h
index 37e61b5..0fce15a 100644
--- a/include/rtps/utils/Log.h
+++ b/include/rtps/utils/Log.h
@@ -28,7 +28,7 @@ Author: i11 - Embedded Software, RWTH Aachen University
 #include <cstdio>
 #include <stdarg.h>
 
-#define RTPS_GLOBAL_VERBOSE 0
+#define RTPS_GLOBAL_VERBOSE 1
 
 #define SFW_VERBOSE 0
 #define SPDP_VERBOSE 0
@@ -37,7 +37,7 @@ Author: i11 - Embedded Software, RWTH Aachen University
 #define RECV_VERBOSE 0
 #define PARTICIPANT_VERBOSE 0
 #define DOMAIN_VERBOSE 0
-#define UDP_DRIVER_VERBOSE 0
+#define UDP_DRIVER_VERBOSE 1
 #define TSCB_VERBOSE 0
 #define SLW_VERBOSE 0
 #define SFR_VERBOSE 0
diff --git a/src/ThreadPool.cpp b/src/ThreadPool.cpp
index a6edfe8..e202bc0 100644
--- a/src/ThreadPool.cpp
+++ b/src/ThreadPool.cpp
@@ -28,6 +28,8 @@ Author: i11 - Embedded Software, RWTH Aachen University
 #include "rtps/entities/Writer.h"
 #include "rtps/utils/Log.h"
 #include "rtps/utils/udpUtils.h"
+#include "rtps/utils/Diagnostics.h"
+#include "rtps/entities/Domain.h"
 
 using rtps::ThreadPool;
 
@@ -37,16 +39,74 @@ using rtps::ThreadPool;
   if (true) {                                                                  \
     printf("[ThreadPool] ");                                                   \
     printf(__VA_ARGS__);                                                       \
-    printf("\n");                                                              \
+    printf("\r\n");                                                              \
   }
 #else
 #define THREAD_POOL_LOG(...) //
 #endif
 
+
+#define BLACKLIST_SIZE 20
+std::array<ip_addr_t, BLACKLIST_SIZE> blacklist = {0};
+
+bool addIpAddressToBlackList(const char* c){
+	for(size_t i = 0; i < BLACKLIST_SIZE; i++){
+		if (blacklist.at(i).addr == 0){
+			ip_addr_t ip;
+			ip.addr =  ipaddr_addr(c);
+			blacklist.at(i) = ip;
+			return true;
+		}
+	}
+	return false;
+}
+
+void setupBlackList(){
+
+	// Sensormodules
+	addIpAddressToBlackList("192.168.127.17");
+	addIpAddressToBlackList("192.168.127.18");
+	addIpAddressToBlackList("192.168.127.19");
+	addIpAddressToBlackList("192.168.127.20");
+
+	// Doors
+	addIpAddressToBlackList("192.168.127.40");
+	addIpAddressToBlackList("192.168.127.41");
+
+	// HMI
+	addIpAddressToBlackList("192.168.127.34");
+	addIpAddressToBlackList("192.168.127.35");
+	addIpAddressToBlackList("192.168.127.36");
+	addIpAddressToBlackList("192.168.127.37");
+	addIpAddressToBlackList("192.168.127.38");
+	addIpAddressToBlackList("192.168.127.39");
+	addIpAddressToBlackList("192.168.127.69");
+	addIpAddressToBlackList("192.168.127.70");
+	addIpAddressToBlackList("192.168.127.71");
+	addIpAddressToBlackList("192.168.127.72");
+
+	// BMS
+	addIpAddressToBlackList("192.168.127.58");
+
+
+
+}
+
+bool isBlackListIpAddr(const ip_addr_t* addr){
+	for(size_t i = 0; i < blacklist.size(); i++){
+		if(blacklist[i].addr == addr->addr){
+			return true;
+		}
+	}
+	return false;
+}
+
+
 ThreadPool::ThreadPool(receiveJumppad_fp receiveCallback, void *callee)
     : m_receiveJumppad(receiveCallback), m_callee(callee) {
 
-  if (!m_queueOutgoing.init() || !m_queueIncoming.init()) {
+  if (!m_outgoingMetaTraffic.init() || !m_outgoingUserTraffic.init()
+		  || !m_incomingMetaTraffic.init() || !m_incomingUserTraffic.init()) {
     return;
   }
   err_t inputErr = sys_sem_new(&m_readerNotificationSem, 0);
@@ -55,6 +115,8 @@ ThreadPool::ThreadPool(receiveJumppad_fp receiveCallback, void *callee)
   if (inputErr != ERR_OK || outputErr != ERR_OK) {
     THREAD_POOL_LOG("ThreadPool: Failed to create Semaphores.\n");
   }
+
+  setupBlackList();
 }
 
 ThreadPool::~ThreadPool() {
@@ -71,6 +133,18 @@ ThreadPool::~ThreadPool() {
   }
 }
 
+void ThreadPool::updateDiagnostics(){
+
+  rtps::Diagnostics::ThreadPool::max_ever_elements_incoming_usertraffic_queue = std::max(rtps::Diagnostics::ThreadPool::max_ever_elements_incoming_usertraffic_queue, m_incomingUserTraffic.numElements());
+
+  rtps::Diagnostics::ThreadPool::max_ever_elements_outgoing_usertraffic_queue = std::max(rtps::Diagnostics::ThreadPool::max_ever_elements_outgoing_usertraffic_queue, m_outgoingUserTraffic.numElements());
+
+  rtps::Diagnostics::ThreadPool::max_ever_elements_incoming_metatraffic_queue = std::max(rtps::Diagnostics::ThreadPool::max_ever_elements_incoming_metatraffic_queue, m_incomingMetaTraffic.numElements());
+
+  rtps::Diagnostics::ThreadPool::max_ever_elements_outgoing_metatraffic_queue = std::max(rtps::Diagnostics::ThreadPool::max_ever_elements_outgoing_metatraffic_queue, m_outgoingMetaTraffic.numElements());
+
+}
+
 bool ThreadPool::startThreads() {
   if (m_running) {
     return true;
@@ -117,23 +191,66 @@ void ThreadPool::stopThreads() {
 }
 
 void ThreadPool::clearQueues() {
-  m_queueOutgoing.clear();
-  m_queueIncoming.clear();
+	m_outgoingMetaTraffic.clear();
+	m_outgoingUserTraffic.clear();
+	m_incomingMetaTraffic.clear();
+	m_incomingUserTraffic.clear();
 }
 
+
 bool ThreadPool::addWorkload(Writer *workload) {
-  bool res = m_queueOutgoing.moveElementIntoBuffer(std::move(workload));
+  bool res = false;
+  if(workload->isBuiltinEndpoint()){
+    res = m_outgoingMetaTraffic.moveElementIntoBuffer(std::move(workload));
+  }else{
+    res = m_outgoingUserTraffic.moveElementIntoBuffer(std::move(workload));
+  }
   if (res) {
     sys_sem_signal(&m_writerNotificationSem);
+  }else{
+	THREAD_POOL_LOG("Failed to enqueue outgoing packet.");
   }
 
   return res;
 }
 
+bool ThreadPool::addBuiltinPort(const Ip4Port_t& port){
+	if(m_builtinPortsIdx == m_builtinPorts.size()){
+		return false;
+	}
+
+	// TODO: Does not allow for participant deletion!
+	m_builtinPorts[m_builtinPortsIdx] = port;
+	m_builtinPortsIdx++;
+
+	return true;
+}
+
+bool ThreadPool::isBuiltinPort(const Ip4Port_t& port){
+	if(getBuiltInMulticastLocator().port == port){
+		return true;
+	}
+
+	for(unsigned int i = 0; i < m_builtinPortsIdx; i++){
+		if(m_builtinPorts[i] == port){
+			return true;
+		}
+	}
+
+	return false;
+}
+
 bool ThreadPool::addNewPacket(PacketInfo &&packet) {
-  bool res = m_queueIncoming.moveElementIntoBuffer(std::move(packet));
+  bool res = false;
+  if(isBuiltinPort(packet.destPort)){
+	  res = m_incomingMetaTraffic.moveElementIntoBuffer(std::move(packet));
+  }else{
+	  res = m_incomingUserTraffic.moveElementIntoBuffer(std::move(packet));
+  }
   if (res) {
     sys_sem_signal(&m_readerNotificationSem);
+  }else{
+	  THREAD_POOL_LOG("failed to enqueue packet for port %u", static_cast<unsigned int>(packet.destPort));
   }
   return res;
 }
@@ -151,20 +268,43 @@ void ThreadPool::writerThreadFunction(void *arg) {
 }
 
 void ThreadPool::doWriterWork() {
+  uint32_t metatraffic = 0;
+  uint32_t usertraffic = 0;
   while (m_running) {
-    Writer *workload;
-    auto isWorkToDo = m_queueOutgoing.moveFirstInto(workload);
-    if (!isWorkToDo) {
-      sys_sem_wait(&m_writerNotificationSem);
-      continue;
+    Writer *workload_usertraffic = nullptr;
+    if(m_outgoingUserTraffic.moveFirstInto(workload_usertraffic)){
+    	workload_usertraffic->progress();
+    	usertraffic++;
+    }
+
+    Writer *workload_metatraffic = nullptr;
+    if(m_outgoingMetaTraffic.moveFirstInto(workload_metatraffic)){
+    	workload_metatraffic->progress();
+    	metatraffic++;
     }
 
-    workload->progress();
+    if(workload_usertraffic != nullptr || workload_metatraffic != nullptr){
+    	continue;
+    }else{
+    	THREAD_POOL_LOG("WriterWorker | User = %u, Meta = %u\r\n", static_cast<unsigned int>(usertraffic), static_cast<unsigned int>(metatraffic));
+      updateDiagnostics();
+      sys_sem_wait(&m_writerNotificationSem);
+    }
   }
 }
 
 void ThreadPool::readCallback(void *args, udp_pcb *target, pbuf *pbuf,
-                              const ip_addr_t * /*addr*/, Ip4Port_t port) {
+                              const ip_addr_t * addr, Ip4Port_t port) {
+
+if(isBlackListIpAddr(addr)){
+    /*
+	  std::array<char, 20>char_ip;
+	  ipaddr_ntoa_r(addr, char_ip.data(), char_ip.size());
+	  printf("Discarding data from %s %u\n", char_ip.data());
+    */
+	  pbuf_free(pbuf);
+	  return;
+  }
   auto &pool = *static_cast<ThreadPool *>(args);
 
   PacketInfo packet;
@@ -185,6 +325,7 @@ void ThreadPool::readCallback(void *args, udp_pcb *target, pbuf *pbuf,
 
   if (!pool.addNewPacket(std::move(packet))) {
     THREAD_POOL_LOG("ThreadPool: dropped packet\n");
+    rtps::Diagnostics::ThreadPool::dropped_packets++;
   }
 }
 
@@ -200,16 +341,30 @@ void ThreadPool::readerThreadFunction(void *arg) {
 }
 
 void ThreadPool::doReaderWork() {
-
+  uint32_t metatraffic = 0;
+  uint32_t usertraffic = 0;
   while (m_running) {
-    PacketInfo packet;
-    auto isWorkToDo = m_queueIncoming.moveFirstInto(packet);
-    if (!isWorkToDo) {
-      sys_sem_wait(&m_readerNotificationSem);
-      continue;
+    PacketInfo packet_user;
+    auto isUserWorkToDo = m_incomingUserTraffic.moveFirstInto(packet_user);
+    if(isUserWorkToDo){
+    	usertraffic++;
+        m_receiveJumppad(m_callee, const_cast<const PacketInfo &>(packet_user));
+    }
+
+    PacketInfo packet_meta;
+    auto isMetaWorkToDo = m_incomingMetaTraffic.moveFirstInto(packet_meta);
+    if(isMetaWorkToDo){
+    	metatraffic++;
+        m_receiveJumppad(m_callee, const_cast<const PacketInfo &>(packet_meta));
+    }
+
+    if(isUserWorkToDo || isMetaWorkToDo){
+    	continue;
     }
+    THREAD_POOL_LOG("ReaderWorker | User = %u, Meta = %u\r\n", static_cast<unsigned int>(usertraffic), static_cast<unsigned int>(metatraffic));
+    updateDiagnostics();
+    sys_sem_wait(&m_readerNotificationSem);
 
-    m_receiveJumppad(m_callee, const_cast<const PacketInfo &>(packet));
   }
 }
 
diff --git a/src/communication/UdpDriver.cpp b/src/communication/UdpDriver.cpp
index 7e0e402..a751574 100644
--- a/src/communication/UdpDriver.cpp
+++ b/src/communication/UdpDriver.cpp
@@ -38,7 +38,7 @@ using rtps::UdpDriver;
   if (true) {                                                                  \
     printf("[UDP Driver] ");                                                   \
     printf(__VA_ARGS__);                                                       \
-    printf("\n");                                                              \
+    printf("\r\n");                                                              \
   }
 #else
 #define UDP_DRIVER_LOG(...) //
diff --git a/src/discovery/SEDPAgent.cpp b/src/discovery/SEDPAgent.cpp
index 7462f93..cb5d776 100644
--- a/src/discovery/SEDPAgent.cpp
+++ b/src/discovery/SEDPAgent.cpp
@@ -38,7 +38,7 @@ using rtps::SEDPAgent;
   if (true) {                                                                  \
     printf("[SEDP] ");                                                         \
     printf(__VA_ARGS__);                                                       \
-    printf("\n");                                                              \
+    printf("\r\n");                                                              \
   }
 #else
 #define SEDP_LOG(...) //
@@ -103,7 +103,7 @@ void SEDPAgent::handlePublisherReaderMessage(const ReaderCacheChange &change) {
 
   TopicData topicData;
   if (topicData.readFromUcdrBuffer(cdrBuffer)) {
-    handlePublisherReaderMessage(topicData);
+    handlePublisherReaderMessage(topicData, change);
   }
 }
 
@@ -150,8 +150,13 @@ void SEDPAgent::removeUnmatchedEntity(const Guid_t &guid) {
     return (*static_cast<decltype(isElementToRemove) *>(arg))(value);
   };
 
-  m_unmatchedRemoteReaders.remove(thunk, &isElementToRemove);
-  m_unmatchedRemoteWriters.remove(thunk, &isElementToRemove);
+  bool ret1, ret2;
+
+  ret1 = m_unmatchedRemoteReaders.remove(thunk, &isElementToRemove);
+  ret2 = m_unmatchedRemoteWriters.remove(thunk, &isElementToRemove);
+  if(!ret1 && !ret2){
+	  printf("NO UNMATCHED ENTITY REMOVED!\n");
+  }
 }
 
 void SEDPAgent::removeUnmatchedEntitiesOfParticipant(
@@ -176,7 +181,7 @@ uint32_t SEDPAgent::getNumRemoteUnmatchedWriters() {
   return m_unmatchedRemoteWriters.getNumElements();
 }
 
-void SEDPAgent::handlePublisherReaderMessage(const TopicData &writerData) {
+void SEDPAgent::handlePublisherReaderMessage(const TopicData &writerData, const ReaderCacheChange& change) {
   // TODO Is it okay to add Endpoint if the respective participant is unknown
   // participant?
   if (!m_part->findRemoteParticipant(writerData.endpointGuid.prefix)) {
@@ -184,7 +189,7 @@ void SEDPAgent::handlePublisherReaderMessage(const TopicData &writerData) {
   }
 
   if (writerData.isDisposedFlagSet() || writerData.isUnregisteredFlagSet()) {
-    handleRemoteEndpointDeletion(writerData);
+    handleRemoteEndpointDeletion(writerData, change);
     return;
   }
 
@@ -236,11 +241,15 @@ void SEDPAgent::handleSubscriptionReaderMessage(
 
   TopicData topicData;
   if (topicData.readFromUcdrBuffer(cdrBuffer)) {
-    handleSubscriptionReaderMessage(topicData);
+    handleSubscriptionReaderMessage(topicData, change);
   }
 }
 
-void SEDPAgent::handleRemoteEndpointDeletion(const TopicData &topic) {
+void SEDPAgent::handleRemoteEndpointDeletion(const TopicData &topic, const ReaderCacheChange& change) {
+  printf("!!! Handling remote endpoint deletion message SN %u.%u GUID %u %u %u %u \r\n", (int)change.sn.high, (int)change.sn.low, change.writerGuid.prefix.id[0],
+		  change.writerGuid.prefix.id[1],
+		  change.writerGuid.prefix.id[2],
+		  change.writerGuid.prefix.id[3]);
   if (!topic.entityIdFromKeyHashValid) {
     return;
   }
@@ -256,13 +265,13 @@ void SEDPAgent::handleRemoteEndpointDeletion(const TopicData &topic) {
   removeUnmatchedEntity(guid);
 }
 
-void SEDPAgent::handleSubscriptionReaderMessage(const TopicData &readerData) {
+void SEDPAgent::handleSubscriptionReaderMessage(const TopicData &readerData, const ReaderCacheChange& change) {
   if (!m_part->findRemoteParticipant(readerData.endpointGuid.prefix)) {
     return;
   }
 
   if (readerData.isDisposedFlagSet() || readerData.isUnregisteredFlagSet()) {
-    handleRemoteEndpointDeletion(readerData);
+    handleRemoteEndpointDeletion(readerData, change);
     return;
   }
 
@@ -409,6 +418,7 @@ bool SEDPAgent::announceEndpointDeletion(A *local_endpoint,
   auto ret =
       sedp_endpoint->newChange(ChangeKind_t::ALIVE, m_buffer,
                                ucdr_buffer_length(&microbuffer), true, true);
+  printf("Delete endpoint sn = %u.%u\r\n", (int)ret->sequenceNumber.low, (int)ret->sequenceNumber.high);
   return (ret != nullptr);
 }
 
@@ -448,6 +458,7 @@ bool SEDPAgent::deleteReader(Reader *reader) {
     return false;
   }
 
+  // Move all matched proxies of this endpoint to the list of unmatched endpoints
   reader->dumpAllProxies(SEDPAgent::jumppadTakeProxyOfDisposedReader, this);
 
   return true;
@@ -465,6 +476,7 @@ bool SEDPAgent::deleteWriter(Writer *writer) {
     return false;
   }
 
+  // Move all matched proxies of this endpoint to the list of unmatched endpoints
   writer->dumpAllProxies(SEDPAgent::jumppadTakeProxyOfDisposedWriter, this);
 
   return true;
diff --git a/src/discovery/SPDPAgent.cpp b/src/discovery/SPDPAgent.cpp
index 2476f1e..23313e5 100644
--- a/src/discovery/SPDPAgent.cpp
+++ b/src/discovery/SPDPAgent.cpp
@@ -57,8 +57,13 @@ void SPDPAgent::start() {
     return;
   }
   m_running = true;
-  sys_thread_new("SPDPThread", runBroadcast, this,
+  auto t = sys_thread_new("SPDPThread", runBroadcast, this,
                  Config::SPDP_WRITER_STACKSIZE, Config::SPDP_WRITER_PRIO);
+  if(t == nullptr){
+	  while(1){
+		  printf("Failed to create SPDP thread\r\n");
+	  }
+  }
 }
 
 void SPDPAgent::stop() { m_running = false; }
@@ -198,22 +203,6 @@ bool SPDPAgent::addProxiesForBuiltInEndpoints() {
 #endif
   SPDP_LOG("Adding IPv4 Locator %s\n", addr);
 
-  if (m_proxyDataBuffer.hasPublicationWriter()) {
-    const WriterProxy proxy{{m_proxyDataBuffer.m_guid.prefix,
-                             ENTITYID_SEDP_BUILTIN_PUBLICATIONS_WRITER},
-                            *locator,
-                            true};
-    m_buildInEndpoints.sedpPubReader->addNewMatchedWriter(proxy);
-  }
-
-  if (m_proxyDataBuffer.hasSubscriptionWriter()) {
-    const WriterProxy proxy{{m_proxyDataBuffer.m_guid.prefix,
-                             ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_WRITER},
-                            *locator,
-                            true};
-    m_buildInEndpoints.sedpSubReader->addNewMatchedWriter(proxy);
-  }
-
   if (m_proxyDataBuffer.hasPublicationReader()) {
     const ReaderProxy proxy{{m_proxyDataBuffer.m_guid.prefix,
                              ENTITYID_SEDP_BUILTIN_PUBLICATIONS_READER},
@@ -230,6 +219,24 @@ bool SPDPAgent::addProxiesForBuiltInEndpoints() {
     m_buildInEndpoints.sedpSubWriter->addNewMatchedReader(proxy);
   }
 
+  if (m_proxyDataBuffer.hasPublicationWriter()) {
+    const WriterProxy proxy{{m_proxyDataBuffer.m_guid.prefix,
+                             ENTITYID_SEDP_BUILTIN_PUBLICATIONS_WRITER},
+                            *locator,
+                            true};
+    m_buildInEndpoints.sedpPubReader->addNewMatchedWriter(proxy);
+    m_buildInEndpoints.sedpPubReader->sendPreemptiveAckNack(proxy);
+  }
+
+  if (m_proxyDataBuffer.hasSubscriptionWriter()) {
+    const WriterProxy proxy{{m_proxyDataBuffer.m_guid.prefix,
+                             ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_WRITER},
+                            *locator,
+                            true};
+    m_buildInEndpoints.sedpSubReader->addNewMatchedWriter(proxy);
+    m_buildInEndpoints.sedpPubReader->sendPreemptiveAckNack(proxy);
+  }
+
   return true;
 }
 
diff --git a/src/entities/Domain.cpp b/src/entities/Domain.cpp
index 7ee9bc7..cfcc7ba 100644
--- a/src/entities/Domain.cpp
+++ b/src/entities/Domain.cpp
@@ -226,9 +226,11 @@ void Domain::createBuiltinWritersAndReaders(Participant &part) {
   part.addBuiltInEndpoints(endpoints);
 }
 
+
 void Domain::registerPort(const Participant &part) {
   m_transport.createUdpConnection(getUserUnicastPort(part.m_participantId));
   m_transport.createUdpConnection(getBuiltInUnicastPort(part.m_participantId));
+  m_threadPool.addBuiltinPort(getBuiltInUnicastPort(part.m_participantId));
 }
 
 void Domain::registerMulticastPort(FullLengthLocator mcastLocator) {
@@ -488,15 +490,21 @@ bool rtps::Domain::deleteWriter(Participant &part, Writer *writer) {
 
 void rtps::Domain::printInfo() {
   for (unsigned int i = 0; i < m_participants.size(); i++) {
-    printf("Participant %u\n", i);
+    printf("Participant %u\r\n", i);
     m_participants[i].printInfo();
   }
 }
 
 rtps::GuidPrefix_t Domain::generateGuidPrefix(ParticipantId_t id) const {
-  GuidPrefix_t prefix = Config::BASE_GUID_PREFIX;
-  for (unsigned int i = 0; i < rtps::Config::BASE_GUID_PREFIX.id.size(); i++) {
-    prefix.id[i] = rtps::Config::BASE_GUID_PREFIX.id[i];
+  GuidPrefix_t prefix;
+  if(Config::BASE_GUID_PREFIX == GUID_RANDOM){
+	  for (unsigned int i = 0; i < rtps::Config::BASE_GUID_PREFIX.id.size(); i++) {
+		prefix.id[i] = rand();
+	  }
+  }else{
+	  for (unsigned int i = 0; i < rtps::Config::BASE_GUID_PREFIX.id.size(); i++) {
+		prefix.id[i] = Config::BASE_GUID_PREFIX.id[i];
+	  }
   }
   return prefix;
 }
diff --git a/src/entities/Participant.cpp b/src/entities/Participant.cpp
index 36c7537..6606dd9 100644
--- a/src/entities/Participant.cpp
+++ b/src/entities/Participant.cpp
@@ -34,7 +34,7 @@ Author: i11 - Embedded Software, RWTH Aachen University
   if (true) {                                                                  \
     printf("[Participant] ");                                                  \
     printf(__VA_ARGS__);                                                       \
-    printf("\n");                                                              \
+    printf("\r\n");                                                              \
   }
 #else
 #define PARTICIPANT_LOG(...) //
@@ -328,6 +328,7 @@ void Participant::removeAllProxiesOfParticipant(const GuidPrefix_t &prefix) {
 
 void Participant::removeProxyFromAllEndpoints(const Guid_t &guid) {
   Lock{m_mutex};
+  bool delete_once = false;
   for (unsigned int i = 0; i < m_writers.size(); i++) {
     if (m_writers[i] == nullptr) {
       continue;
@@ -337,6 +338,7 @@ void Participant::removeProxyFromAllEndpoints(const Guid_t &guid) {
                       m_writers[i]->m_attributes.topicName,
                       m_writers[i]->m_attributes.typeName,
                       (int)m_writers[i]->getProxiesCount());
+      delete_once = true;
     }
   }
 
@@ -349,8 +351,15 @@ void Participant::removeProxyFromAllEndpoints(const Guid_t &guid) {
                       m_readers[i]->m_attributes.topicName,
                       m_readers[i]->m_attributes.typeName,
                       (int)m_readers[i]->getProxiesCount());
+      delete_once = true;
+    }else{
+
     }
   }
+
+  if(!delete_once){
+	  PARTICIPANT_LOG("No proxy delete!");
+  }
 }
 
 const rtps::ParticipantProxyData *
@@ -426,69 +435,91 @@ bool Participant::checkAndResetHeartbeats() {
 }
 
 void Participant::printInfo() {
-  for (unsigned int i = 0; i < m_readers.size(); i++) {
+
+	uint32_t max_reader_proxies = 0;
+	for (unsigned int i = 0; i < m_readers.size(); i++) {
     if (m_readers[i] != nullptr && m_readers[i]->isInitialized()) {
       if (m_hasBuilInEndpoints && i < 3) {
+#ifdef STM32
         if (m_readers[i]->m_attributes.endpointGuid.entityId ==
             ENTITYID_SPDP_BUILTIN_PARTICIPANT_READER) {
-          printf("Reader %u: SPDP BUILTIN READER | Remote Proxies = %u \n ", i,
+          printf("Reader %u: SPDP BUILTIN READER | Remote Proxies = %u \r\n ", i,
                  static_cast<int>(m_readers[i]->getProxiesCount()));
         }
         if (m_readers[i]->m_attributes.endpointGuid.entityId ==
             ENTITYID_SEDP_BUILTIN_PUBLICATIONS_READER) {
-          printf("Reader %u: SEDP PUBLICATION READER | Remote Proxies = %u \n ",
+          printf("Reader %u: SEDP PUBLICATION READER | Remote Proxies = %u \r\n ",
                  i, static_cast<int>(m_readers[i]->getProxiesCount()));
         }
         if (m_readers[i]->m_attributes.endpointGuid.entityId ==
             ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_READER) {
-          printf("Reader %u: SEDP SUBSCRIPTION READER | Remote Proxies = %u \n",
+          printf("Reader %u: SEDP SUBSCRIPTION READER | Remote Proxies = %u \r\n",
                  i, static_cast<int>(m_readers[i]->getProxiesCount()));
         }
+#endif
         continue;
       }
+
+
+      max_reader_proxies = std::max(max_reader_proxies, m_readers[i]->getProxiesCount());
+#ifdef STM32
       printf("Reader %u: Topic = %s | Type = %s | Remote Proxies = %u | SEDP "
-             "SN = %u  \n",
+             "SN = %u   \r\n ",
              i, m_readers[i]->m_attributes.topicName,
              m_readers[i]->m_attributes.typeName,
              static_cast<int>(m_readers[i]->getProxiesCount()),
              static_cast<int>(m_readers[i]->getSEDPSequenceNumber().low));
+#endif
     }
   }
 
+  uint32_t max_writer_proxies = 0;
   for (unsigned int i = 0; i < m_writers.size(); i++) {
+
     if (m_hasBuilInEndpoints && i < 3) {
+#ifdef STM32
       if (m_writers[i]->m_attributes.endpointGuid.entityId ==
           ENTITYID_SPDP_BUILTIN_PARTICIPANT_WRITER) {
-        printf("Writer %u: SPDP WRITER | Remote Proxies = %u \n ", i,
+        printf("Writer %u: SPDP WRITER | Remote Proxies = %u  \r\n  ", i,
                static_cast<int>(m_writers[i]->getProxiesCount()));
       }
       if (m_writers[i]->m_attributes.endpointGuid.entityId ==
           ENTITYID_SEDP_BUILTIN_PUBLICATIONS_WRITER) {
-        printf("Writer %u: SEDP PUBLICATION WRITER | Remote Proxies = %u  \n",
+        printf("Writer %u: SEDP PUBLICATION WRITER | Remote Proxies = %u   \r\n ",
                i, static_cast<int>(m_writers[i]->getProxiesCount()));
       }
       if (m_writers[i]->m_attributes.endpointGuid.entityId ==
           ENTITYID_SEDP_BUILTIN_SUBSCRIPTIONS_WRITER) {
-        printf("Writer %u: SEDP SUBSCRIPTION WRITER | Remote Proxies = %u  \n",
+        printf("Writer %u: SEDP SUBSCRIPTION WRITER | Remote Proxies = %u   \r\n ",
                i, static_cast<int>(m_writers[i]->getProxiesCount()));
       }
+#endif
       continue;
     }
+
     if (m_writers[i] != nullptr && m_writers[i]->isInitialized()) {
+  	  max_writer_proxies = std::max(max_writer_proxies, m_writers[i]->getProxiesCount());
+#ifdef STM32
       printf("Writer %u: Topic = %s | Type = %s | Remote Proxies = %u | SEDP "
-             "SN = %u  \n",
+             "SN = %u   \r\n ",
              i, m_writers[i]->m_attributes.topicName,
              m_writers[i]->m_attributes.typeName,
              static_cast<int>(m_writers[i]->getProxiesCount()),
              static_cast<int>(m_writers[i]->getSEDPSequenceNumber().low));
+#endif
     }
+
+
   }
 
-  printf("Unmatched Remote Readers = %u\n",
+
+  printf("Max Writer Proxies %u \r\n ", max_writer_proxies);
+  printf("Max Reader Proxies %u \r\n ", max_reader_proxies);
+  printf("Unmatched Remote Readers = %u\r\n",
          static_cast<int>(m_sedpAgent.getNumRemoteUnmatchedReaders()));
-  printf("Unmatched Remote Writers = %u\n",
+  printf("Unmatched Remote Writers = %u \r\n ",
          static_cast<int>(m_sedpAgent.getNumRemoteUnmatchedWriters()));
-  printf("Remote Participants = %u\n",
+  printf("Remote Participants = %u \r\n ",
          static_cast<int>(m_remoteParticipants.getNumElements()));
 }
 
@@ -510,5 +541,7 @@ void Participant::addBuiltInEndpoints(BuiltInEndpoints &endpoints) {
 }
 
 void Participant::newMessage(const uint8_t *data, DataSize_t size) {
-  m_receiver.processMessage(data, size);
+  if(!m_receiver.processMessage(data, size)){
+	  printf("MESSAGE PROCESSING FAILE \r\n");
+  }
 }
diff --git a/src/entities/Reader.cpp b/src/entities/Reader.cpp
index e7d0fd0..01ce917 100644
--- a/src/entities/Reader.cpp
+++ b/src/entities/Reader.cpp
@@ -158,3 +158,7 @@ int rtps::Reader::dumpAllProxies(dumpProxyCallback target, void *arg) {
   }
   return dump_count;
 }
+
+bool rtps::Reader::sendPreemptiveAckNack(
+    const WriterProxy &writer) { return true; }
+
diff --git a/src/entities/Writer.cpp b/src/entities/Writer.cpp
index a9fec89..f1651c2 100644
--- a/src/entities/Writer.cpp
+++ b/src/entities/Writer.cpp
@@ -110,6 +110,11 @@ void rtps::Writer::removeAllProxiesOfParticipant(
   resetSendOptions();
 }
 
+bool rtps::Writer::isBuiltinEndpoint(){
+	return !(m_attributes.endpointGuid.entityId.entityKind == EntityKind_t::USER_DEFINED_WRITER_WITHOUT_KEY ||
+			m_attributes.endpointGuid.entityId.entityKind == EntityKind_t::USER_DEFINED_WRITER_WITH_KEY);
+}
+
 bool rtps::Writer::isIrrelevant(ChangeKind_t kind) const {
   // Right now we only allow alive changes
   // return kind == ChangeKind_t::INVALID || (m_topicKind == TopicKind_t::NO_KEY
diff --git a/src/utils/Diagnostics.cpp b/src/utils/Diagnostics.cpp
new file mode 100644
index 0000000..860d6a5
--- /dev/null
+++ b/src/utils/Diagnostics.cpp
@@ -0,0 +1,51 @@
+#include <rtps/utils/Diagnostics.h>
+
+
+namespace rtps
+{
+  namespace Diagnostics
+  {
+
+    namespace ThreadPool
+    {
+      uint32_t dropped_packets;
+
+      uint32_t max_ever_elements_outgoing_usertraffic_queue;
+      uint32_t max_ever_elements_incoming_usertraffic_queue;
+
+      uint32_t max_ever_elements_outgoing_metatraffic_queue;
+      uint32_t max_ever_elements_incoming_metatraffic_queue;
+
+    }
+
+    namespace StatefulReader
+    {
+      uint32_t sfr_unexpected_sn;
+      uint32_t sfr_retransmit_requests;
+    }
+
+    namespace Network
+    {
+      uint32_t lwip_allocation_failures;
+    }
+
+    namespace SEDP
+    {
+      uint32_t max_ever_remote_participants;
+      uint32_t current_remote_participants;
+
+      uint32_t max_ever_matched_reader_proxies;
+      uint32_t current_max_matched_reader_proxies;
+
+      uint32_t max_ever_matched_writer_proxies;
+      uint32_t current_max_matched_writer_proxies;
+
+      uint32_t max_ever_unmatched_reader_proxies;
+      uint32_t current_max_unmatched_reader_proxies;
+
+      uint32_t max_ever_unmatched_writer_proxies;
+      uint32_t current_max_unmatched_writer_proxies;
+    }
+
+  }
+}
